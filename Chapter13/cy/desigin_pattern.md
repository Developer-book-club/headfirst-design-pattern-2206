# 디자인 패턴

### 1. 패턴은 특정 컨텍스트 내에서 주어진 문제의 해결책이다

<br>

     어떤 컨텍스트 내에서 일련의 제약조건에 의해 영향을 받는 문제가 발생하면, 그 제약조건 내에서 목적 달성을 위한 해결책이 되는 디자인을 적용하면 된다.

- 컨텍스트(contenxt) : 패턴의 적용되는 상황 (반복적으로 일어날 수 있는 상황)
- 문제(problem): 컨텍스트 내에서 이뤄야 하는 목표, 제약 조건
- 해결책(solution): 제약 조건 내에서 누가 적용해도 목표룰 이룰 수 있는 일반적인 디자인

<br>

### 2. 디자인 패턴 분류

<br>

  2-1. 생성 - 행동 - 구조

  - 생성 패턴: 객체 인스턴스를 생성하는 패턴으로, 클라이언트와 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어주는 패턴

    -> 싱글턴, 추상 팩토리, 팩토리 메소드, 프로토타입, 빌더 등 
  
  - 행동 패턴: 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴

    -> 템플릿 메소드, 싱글턴, 반복자, 옵저버, 상태, 전략, 비지터, 중재자, 인터프리터 등
  
  - 구조 패턴: 클래스와 객체를 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴

    -> 데코레이터, 프록시, 퍼사드, 컴포지트, 어댑터, 브리지, 플라이웨이트
  
  2-2. 클래스 - 객체
 
  - 클래스 패턴: 클래스 사이의 관계가 상속으로 어떻게 정의되는지를 다룬다. 클래스 사이의 관계는 대부분 컴파일할 때 결정된다.

    -> 팩토리 메소드, 템플릿 메소드, 어댑터, 인터프리터 등
  
  - 객체 패턴: 객체 사이의 관계를 다루며, 보통 구성으로 정의된다. 런타임에 관계가 결정되므로 보다 동적이고 유연하다.

    -> 컴포지트, 데코레이터, 프록시, 퍼사트, 싱글턴, 옵저버, 상태 등
  
<br>

### 3. 패턴은 만병통치약이 아니다

<br>
  
- 최대한 단순한 방법으로 문제 해결한다.
- 패턴을 사용하면 복잡성이 증가할 수 있다. 디자인 상 문제에 적합하다는 확신이 들 때 패턴을 도입한다.
- 패턴보다 간단한 해결책이 더 나을 것 같으면 패턴을 제거한다.
  
  
### 4. 패턴 정리

- 데코레이터 패턴: 객체를 감싸서 새로운 행동을 제공한다.
- 상태 패턴: 상태를 기반으로 하는 행동을 캡슐화한 다음 위임으로 필요한 행동을 선택한다.
- 반복자 패턴: 컬렉션이 어떤 식으로 구현되었는지 드러내지 않으면서도 컬렉션 내에 있는 모든 객체를 대상으로 반복 작업을 처리할 수 있게 해준다.
- 퍼사드 패턴: 일련의 클래스에 간단한 인터페이스를 제공한다.
- 전략 패턴: 교환 가능한 행동을 캡슐화하고 위임으로 어떤 행동을 사용할지 결정한다.
- 프록시 패턴: 객체를 감싸서 그 객체로의 접근을 제어한다.
- 팩토리 메소드 패턴: 서브클래스에서 생성할 구상 클래스를 결정한다.
- 어댑터 패턴: 객체를 감싸서 다른 인터페이스를 제공한다.
- 옵저버 패턴: 상태가 변경되면 다른 객체들에게 연락을 돌릴 수 있게 해준다.
- 템플릿 메소드 패턴: 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
- 컴포지트 패턴: 클라이언트에서 객체 컬렉션과 개별 객체를 똑같이 다룰 수 있도록 해준다.
- 싱글턴 패턴: 딱 한 객체만 생성되도록 한다.
- 추상 팩토리 패턴: 클라이언트에서 구상 클래스를 지정하지 않으면서도 객체군을 생성할 수 있도록 해준다.
- 커맨드 패턴: 요청을 객체로 감싼다.
