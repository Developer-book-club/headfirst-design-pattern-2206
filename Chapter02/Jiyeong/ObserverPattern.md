<h1>객체들에게 연락 돌리기</h1>

<h2>Observer Pattern</h2>
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의.

A. 인터페이스가 아닌 구체적인 구현을 바탕으로 코딩함. <br>
B. 새로운 디스플레이 항목이 추가될 때마다 코드를 변경해야 함. <br>
C. 실행 중에는 디스플레이 항목을 추가하거나 제거할 수 없음. <br>
E. 바뀌는 부분을 캡슐화하지 않음. <br>
p.78

<h2>느슨한 결합(Loose Coupling)</h2>
객체들이 상호작용 할 수 있지만, 서로를 잘 모르는 관계를 의미함.

- 주제(Subject)는 옵저버가 특정 인터페이스(Observer Interface)를 구현한다는 사실만 앎.
- 옵저버는 언제든지 새로 추가될 수 있음.
- 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없음.
- 주제와 옵저버는 서로 독립적으로 재사용할 수 있음.
- 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않음.

<h2>객체지향 원칙</h2>
상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용.

<h2>디자인 원칙 경시 대회로 보는 Summary</h2>
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
- 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식이다. 
- 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있다.
- 나중에 바뀔 것을 대비해 두면 편하게 작업이 가능하다.
<br>
2. 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
- 주제와 옵저버에서 모두 인터페이스를 사용했다. 
- 주제는 Subject 인터페이스, Observer 인터페이스를 구현하는 객체들의 등록과 탈퇴를 관리하고, 그런 객체들에게 연락을 돌림.
- 이렇게 되면 느슨한 결합이 가능함.
<br>
3. 상속보다는 구성을 활용한다.
- 옵저버 패턴에서는 구성을 활용해서 옵저버들을 관리한다.
- 주제와 옵저버 사이의 관계는 구성으로 이뤄지며, 실행 중 구성되는 방식을 사용한다.

<h2>낱말 퀴즈로 보는 Summary</h2>
- 하나의 주제가 여러 개의 옵저버에 정보를 보냄.
- 주제는 원래 모든 데이터를 옵저버에 푸시하는 방식으로 보내고자 함.
- 주제는 인터페이스다.
- 결합은 느슨한 것이 좋다.
- 프로그램을 짤 때 구현보다는 인터페이스에 맞추는 것이 좋다.
- 주제는 옵저버들을 잘 몰라도 괜찮다.
- 알림 시 순서에 의존하지 않도록 주의해야 한다.
- 옵저버는 주제에 의존적입니다.
