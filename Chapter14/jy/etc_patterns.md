![](https://velog.velcdn.com/images/jiyeong/post/259f2948-4f96-42e7-b27c-1fdec66cb5e0/image.png)


### Bridge Pattern
구현과 더불어 추상화 부분까지 변경해야할 때 사용함.
사용 시 추상화된 부분과 구현 부분을 서로 다른 클래스 계층 구조로 분리해서 그 둘을 모두 변경이 가능함!

![](https://velog.velcdn.com/images/jiyeong/post/8169d1d2-45be-426b-8306-0e4e4c1e8e19/image.png)
![](https://velog.velcdn.com/images/jiyeong/post/3bfcf4c4-9ee1-4c01-b735-ead556acd665/image.png)


장점 : 
- 구현과 인터페이스를 완전히 결합하지 않았기에 구현과 추상화 부분을 분리 가능
- 추상화된 부분과 실제 구현 부분을 독립적으로 확장 가능
- 추상화 부분을 구현한 구상 클래스가 바뀌어도 클라이언트에는 영향을 끼치지 않음

활용법: 
- 여러 플랫폼에서 사용해야 하는 그래픽스와 윈도우 처리 시스템에서 유용하게 쓰임
- 인터페이스와 실제 구현할 부분을 서로 다른 방식으로 변경해야 할 때 유용

단점:
- 디자인이 복잡해짐

![](https://velog.velcdn.com/images/jiyeong/post/b96fad15-ef84-423b-98b9-634477ec0932/image.png)

### Builder Pattern
제품을 여러 단계로 나눠서 만들도록 제품 생산 단계를 캡슐화하고 싶을 때 사용

![](https://velog.velcdn.com/images/jiyeong/post/1466410f-dc9d-4b9a-8f7f-ad328ec8dc07/image.png)

혹시 반복자 패턴을 아시나요? 그 패턴을 사용하면 반복 작업을 별도의 객체로 캡슐화해서 컬렉션의 내부 구조를 클라이언트로부터 보호할 수 있습니다. 여기에서도 똑같은 아이디어를 사용합니다. 계획표 작성을 객체(빌더라고 부름)에 캡슐화해서 클라이언트가 빌더에게 계획표 구조를 만들어 달라고 요청하도록 만드는 거죠.

![](https://velog.velcdn.com/images/jiyeong/post/47c123fa-6006-4b0a-bf43-14b2aa5ccb39/image.png)

장점 :
- 바로 객체 생성 과정을 캡슐화
- 여러 단계와 다양한 절차를 거쳐 객체를 만듦. 
- 제품 내부 구조를 클라이언트로부터 보호.
- 클라이언트는 추상 인터페이스만 볼 수 있기에 제품을 구현한 코드를 쉽게 바꿀 수 있음.


활용법 :
- 복합 객체 구조를 구축하는 용도로 많이 쓰임

단점:
- 팩토리를 사용할 때보다 객체를 만들 때 클라이언트에 관해 더 많이 알아야 함.

### Chain of Responsibility

![](https://velog.velcdn.com/images/jiyeong/post/f99c8ac4-7a69-4830-90bf-3b43f0279074/image.png)


1개의 요청을 2개 이상의 객체에서 처리할 시 책임 연쇄 패턴 사용.

![](https://velog.velcdn.com/images/jiyeong/post/90803eff-c8de-476b-892f-df683918b1bc/image.png)

이메일이 수신되면 첫 번째 핸들러인 SpamHandler에게 전달됩니다. SpamHandler가 처리할 수 없으면 FanHandler로 넘기죠. 이처럼 사슬을 따라 요청이 전달되면서 적절한 핸들러가 메일을 분류합니다.

![](https://velog.velcdn.com/images/jiyeong/post/d283ded0-8267-4221-9f4e-42cc519a9f45/image.png)


사슬에 들어있는 각 객체는 핸들러 역할을 하며, 객체마다 이어지는 객체가 있음. 주어진 요청을 처리할 수 있으면 직접 처리하고, 그렇지 않으면 다음 객체에 넘긴다.

장점:
- 요청을 보낸 쪽과 받는 쪽 분리 가능
- 객체는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는 다른 객체의 직접적인 레퍼런스를 가질 필요도 없으므로 객체를 단순하게 만들 수 있음
- 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가하거나 제거 가능

활용법:
- 윈도우 시스템에서 마우스 클릭과 키보드 이벤트 처리할 때 흔히 쓰임

단점:
- 요청이 반드시 수행된다는 보장이 없음. 사슬 끝까지 갔는데도 처리가 안 될 수 있음.
- 실행 시에 과정을 살펴보다가 디버깅하기 힘듦.

### Flyweight Pattern
어떤 클래스의 인스턴스 하나로 여러 개의 ‘가상 인스턴스’를 제공.


![](https://velog.velcdn.com/images/jiyeong/post/323ee040-fffb-4428-a966-5839375821ae/image.png)

Tree 객체를 수 천 개 만드는 대신 시스템을 조금 고쳐서 Tree의 인스턴스는 하나만 만들고 모든 나무의 상태를 클라이언트 객체가 관리!

![](https://velog.velcdn.com/images/jiyeong/post/4a83682d-6589-451c-80a4-20e33051954e/image.png)

장점:
- 실행 시에 객체 인스턴스의 개수를 줄여서 메모리를 절약할 수 있음.
- 여러 ‘가상’ 객체의 상태를 한곳에 모아 둘 수 있음.

단점:
- 일단 이 패턴을 써서 구현해 놓으면 특정 인스턴스만 다른 인스턴스와 다르게 행동하게 할 수 없.

활용법 :
- 어떤 클래스의 인스턴스가 아주 많이 필요하지만 모두 똑같은 방식으로 제어해야 할 때 유용하게 쓰임.

### Interpreter Pattern

어떤 언어의 인터프리터를 만들 때 사용.

![](https://velog.velcdn.com/images/jiyeong/post/a875d076-29b2-4764-9902-99ab5809e5df/image.png)
![](https://velog.velcdn.com/images/jiyeong/post/1df883b7-505f-485b-8293-8a7cce687e19/image.png)

인터프리터 패턴은 문법과 구문을 번역하는 인터프리터 클래스를 기반으로 간단한 언어를 정의합니다. 언어에 속하는 규칙을 나타내는 클래스를 사용해서 언어를 표현합니다. 오리 언어를 클래스로 표현하면 다음과 같습니다. 문법과 직접적으로 대응한다는 사실을 확인할 수 있음.

![](https://velog.velcdn.com/images/jiyeong/post/fb32ebb6-c80c-4d1f-9838-92982da43b7c/image.png)

이 언어를 해석하려면 각 표현식에 대응하는 interpret() 메소드를 호출하면 됩니다. 이 메소드에 컨텍스트(파싱하고 있는 프로그램의 입력 스트림이 들어있음)도 전달되며, 입력된 내용을 확인하고 평가하는 작업도 이 메소드가 처리.

장점:
- 문법을 클래스로 표현해서 쉽게 언어를 구현.
- 문법이 클래스로 표현되므로 언어를 쉽게 변경하거나 확장.
- 클래스 구조에 메소드만 추가하면 프로그램을 해석하는 기본 기능 외에 예쁘게 출력하는 기능이나 더 나은 프로그램 확인 기능 같은 새로운 기능을 추가 가능.

단점:
- 문법 규칙의 개수가 많아지면 아주 복잡해진다는 단점이 있습니다. 그럴 때는 파서나 컴파일러 생성기를 쓰는 편이 낫습니다.

활용법:
- 간단한 언어를 구현할 때 인터프리터 패턴이 유용함.
- 효율보다는 단순하고 간단하게 문법을 만드는 것이 더 중요한 경우에 유용함.
- 스크립트 언어와 프로그래밍 언어에서 모두 사용 가능

### Meditator Pattern
서로 관련된 객체 사이의 복잡한 통신과 제어를 한곳으로 집중하고 싶을 때 사용.

![](https://velog.velcdn.com/images/jiyeong/post/704721ac-01f2-4a7e-907f-c45b73fc1acb/image.png)

시스템에 중재자 패턴을 적용하면 가전제품 객체들을 훨씬 단순화할 수 있습니다.

- 상태가 바뀔 때마다 중재자에게 알려 줍니다.

- 중재자에서 보낸 요청에 응답합니다.

 

중재자를 추가하기 전에는 모든 객체가 다른 객체와 서로 알고 있어야 했습니다. 서로 밀접하게 연관되어 있어야 하죠. 하지만 중재자를 사용하면 서로 완전히 분리할 수 있습니다. 중재자에는 모든 시스템을 제어하는 로직이 들어있습니다. 기존 가전제품에 새로운 규칙을 추가하거나 새로운 가전제품을 자동화 시스템에 추가하더라도 그냥 중재자만 고치면 됩니다.

![](https://velog.velcdn.com/images/jiyeong/post/b2f5ccee-9525-40c7-a08d-6634979b5b82/image.png)

장점:

- 시스템과 객체를 분리함으로써 재사용성을 획기적으로 향상시킬 수 있음.
- 제어 로직을 한 군데 모아놨으므로 관리하기가 수월.
- 시스템에 들어있는 객체 사이에서 오가는 메시지를 확 줄이고 단순화할 수 있음.

단점:
- 디자인을 잘 하지 못하면 중재자 객체가 너무 복잡해질 수 있음.

활용법:
- 서로 연관된 GUI 구성 요소를 관리하는 용도로 많이 쓰입니다.

### Memento Pattern
객체를 이전의 상태로 복구해야 한다면 메멘토(Memento) 패턴을 쓴다. 예를 들어, 사용자가 ‘작업 취소’를 요청할 때.

메멘토 패턴 사용하기
메멘토 패턴에는 2가지 목적이 있습니다.

- 시스템에서 핵심적인 기능을 담당하는 객체의 상태 저장
- 심적인 객체의 캡슐화 유지

단일 역할 원칙을 떠올려 본다면, 저장하고자 하는 상태를 핵심 객체로부터 분리해 놓으면 좋겠다는 생각이 들 것입니다. 상태를 따로 저장하는 객체를 메멘토 객체라고 부릅니다.

![](https://velog.velcdn.com/images/jiyeong/post/8f6f9761-2e65-45cb-9724-7c14c2a555a4/image.png)

장점:
- 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관할 수 있어 안전함
- 핵심 객체의 데이터를 계속해서 캡슐화된 상태로 유지 가능
- 복구 기능을 구현하기가 쉬움

단점:
- 상태를 저장하고 복구하는 데 시간이 오래 걸릴 수 있음.

활용법:
-메멘토 객체를 써서 상태를 저장.
- 자바 시스템에서는 시스템의 상태를 저장할 때 직렬화를 사용하는 것이 좋음.

### Prototype Pattern

어떤 클래스의 인스턴스를 만들 때 자원과 시간이 많이 들거나 복잡할 때 사용.

![](https://velog.velcdn.com/images/jiyeong/post/9822f47c-39af-4349-a6d6-a35330d14d52/image.png)

프로토타입 패턴을 사용하면 기존 인스턴스를 복사하기만 해도 새로운 인스턴스를 만들 수 있습니다(자바에서는 clone() 메소드를 사용하거나 역직렬화를 하면 되죠). 이 패턴의 가장 두드러진 특징은 클라이언트 코드에서 어떤 클래스의 인스턴스를 만드는지 전혀 모르는 상태에서도 새로운 인스턴스를 만들 수 있다는 점

![](https://velog.velcdn.com/images/jiyeong/post/32fa586f-0754-40de-815f-ceee7bccab82/image.png)

장점:
- 클라이언트는 새로운 인스턴스를 만드는 과정을 몰라도 됨.
- 클라이언트는 구체적인 형식을 몰라도 객체를 생성할 수 있음.
- 상황에 따라서 객체를 새로 생성하는 것보다 객체를 복사하는 것이 더 효율적일 수 있음.

단점:
- - 때때로 객체의 복사본을 만드는 일이 매우 복잡할 수도 있음.

활용법:
- 시스템에서 복잡한 클래스 계층구조에 파묻혀 있는 다양한 형식의 객체 인스턴스를 새로 만들어야 할 때 유용하게 써먹을 수 있음.

### Visitor Pattern
다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않을 때 사용
![](https://velog.velcdn.com/images/jiyeong/post/7b20ee7e-9a38-4c43-9d80-2c2696b13fb1/image.png)

비지터 객체는 트래버서(Traverser) 객체와 함께 돌아갑니다. 트래버서는 컴포지트 패턴을 쓸 때, 복합 객체 내에 속해 있는 모든 객체에 접근하는 일을 도와주는 역할을 합니다. 비지터 객체에서 복합 객체 내의 모든 객체를 대상으로 원하는 작업을 처리하게 해 주는 거죠. 각각의 상태를 모두 가져오면 클라이언트는 비지터에게 각 상태에 맞는 다양한 작업을 처리하도록 요구할 수 있습니다. 새로운 기능이 필요하게 되더라도 비지터만 고치면 되니까 편리하다.

![](https://velog.velcdn.com/images/jiyeong/post/4fabb2a7-2051-42d9-9d65-22fdbe689775/image.png)


장점:
- 구조를 변경하지 않으면서도 복합 객체 구조에 새로운 기능을 추가 가능.
- 비교적 손쉽게 새로운 기능을 추가 가능.
- 비지터가 수행하는 기능과 관련된 코드를 한곳에 모아 둘 수 있음.

단점:
- 비지터를 사용하면 복합 클래스의 캡슐화가 깨짐.
- 컬렉션 내의 모든 항목에 접근하는 트래버서가 있으므로 복합 구조를 변경하기가 더 어려워짐.


출처 : 한빛미디어

